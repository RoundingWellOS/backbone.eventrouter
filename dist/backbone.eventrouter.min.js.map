/**
 * backbone.eventrouter - A highly opinionated, simplistic Backbone.Router coupled with a Backbone.Radio.Channel
 * @version v0.1.1
 * @link https://github.com/RoundingWellOS/backbone.eventrouter
 * @license MIT
 */
{"version":3,"sources":["/source/backbone.eventrouter.js"],"names":["global","factory","exports","module","require","define","amd","Backbone","EventRouter","_","Radio","this","Router","extend","constructor","options","apply","arguments","pick","_ch","channel","result","_initRoutes","listenTo","navigateFromEvent","channelName","getChannel","_routeTriggers","each","_addRouteTrigger","routes","event","isArray","route","bind","trigger","addRouteTrigger","_route","name","callback","isFunction","wrappedCallback","args","drop","concat","_storeRouteTrigger","_clearRouteTrigger","prototype","call","_routeArgs","push","_getCurrentRouteTrigger","last","pop","_isTriggeredFromRoute","currentRoute","length","union","getDefaultRoute","eventArgs","translatedRoute","translateRoute","navigate","_replaceParam","arg","namedParam","replace","reduce","backbone_eventrouter"],"mappings":"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","file":"backbone.eventrouter.min.js","sourcesContent":["/**\n * backbone.eventrouter - A highly opinionated, simplistic Backbone.Router coupled with a Backbone.Radio.Channel\n * @version v0.1.1\n * @link https://github.com/RoundingWellOS/backbone.eventrouter\n * @license MIT\n */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('underscore'), require('backbone'), require('backbone.radio')) :\n  typeof define === 'function' && define.amd ? define(['underscore', 'backbone', 'backbone.radio'], factory) :\n  global.Backbone.EventRouter = factory(global._, global.Backbone, global.Radio)\n}(this, function (_, Backbone, Radio) { 'use strict';\n\n  var EventRouter = Backbone.EventRouter = Backbone.Router.extend({\n\n    /**\n     * @public\n     * @constructs EventRouter\n     * @param {Object} [options] - Settings for the EventRouter\n     * @param {Boolean} [options.channelName]\n     * @param {Boolean} [options.routeTriggers]\n     */\n    constructor: function(options) {\n      options = _.extend({}, options);\n\n      // Backbone.Router routes are added first\n      // Routes can be added after the triggerRoutes with the Backbone.Router API\n      Backbone.Router.apply(this, arguments);\n\n      _.extend(this, _.pick(options, ['channelName', 'routeTriggers']));\n\n      this._ch = Backbone.Radio.channel(_.result(this, 'channelName'));\n\n      this._initRoutes();\n\n      this.listenTo(this._ch, 'all', this.navigateFromEvent);\n    },\n\n    /**\n     * The Radio Channel name.\n     *\n     * @type {String}\n     * @default 'event-router'\n     */\n    channelName: 'event-router',\n\n    /**\n     * Get the router's Radio channel instance\n     *\n     * @public\n     * @method getChannel\n     * @memberOf EventRouter\n     * @returns {Backbone.Radio.Channel}\n     */\n    getChannel: function() {\n      return this._ch;\n    },\n\n    /**\n     * For each routeTrigger it adds a route to Backbone.Router\n     *\n     * @private\n     * @method _initRoutes\n     * @memberOf EventRouter\n     */\n    _initRoutes: function() {\n      this._routeTriggers = _.result(this, 'routeTriggers') || {};\n\n      _.each(this._routeTriggers, this._addRouteTrigger, this);\n    },\n\n    /**\n     * Adds a route(s) to Backbone.Router which on route triggers\n     * the appropriate event\n     *\n     * @private\n     * @method _addRouteTrigger\n     * @param {Array|String} routes - Route string or array of route strings\n     * @param {String} event - Event string to trigger on route\n     * @memberOf EventRouter\n     */\n    _addRouteTrigger: function(routes, event){\n      // handle any route as an array by default for the _.each\n      routes = _.isArray(routes) ? routes : [routes];\n\n      _.each(routes, function(route) {\n        this.route(route, event, _.bind(this._ch.trigger, this._ch, event));\n      }, this);\n    },\n\n    /**\n     * Adds a routeTrigger, and route(s) to Backbone.Router\n     * which on route triggers the appropriate event.\n     *\n     * @public\n     * @method addRouteTrigger\n     * @param {Array|String} routes - Route string or array of route strings\n     * @param {String} event - Event string to trigger on route\n     * @memberOf EventRouter\n     * @returns {EventRouter}\n     */\n    addRouteTrigger: function(routes, event){\n      this._routeTriggers[event] = routes;\n      this._addRouteTrigger(routes, event);\n\n      return this;\n    },\n\n    /**\n     * Overrides `Backbone.Router.route()\n     * Like Backbone.Router.Route but with before events\n     * It also temporarily stores the event for understanding\n     * what route is currently being handled.\n     *\n     * @public\n     * @method route\n     * @param {String} route - Route string\n     * @param {String} [name] - Name of route\n     * @param {String} callback - Function called on route\n     * @event EventRouter#before:route - passes route name and route arguments\n     * @event EventRouter#before:route:{event_name} - passes route arguments\n     * @memberOf EventRouter\n     * @returns {EventRouter}\n     */\n    route: function(route, name, callback) {\n      if (_.isFunction(name)) {\n        callback = name;\n        name = '';\n      }\n      if (!callback) {\n        callback = this[name];\n      }\n\n      var wrappedCallback = _.bind(function() {\n\n        var args = _.drop(arguments, 0);\n\n        //trigger before: events that match currently triggered events\n        this.trigger('before:route', name, args);\n        this.trigger.apply(this, ['before:route:' + name].concat(args));\n\n        this._storeRouteTrigger([name].concat(args));\n        callback.apply(this, args);\n        this._clearRouteTrigger();\n\n      }, this);\n\n      return Backbone.Router.prototype.route.call(this, route, name, wrappedCallback);\n    },\n\n    /**\n     * Stores the route name and route arguments on a stack\n     *\n     * @private\n     * @method _storeRouteTrigger\n     * @param {Array} args - Array of route name and route arguments\n     * @memberOf EventRouter\n     */\n    _storeRouteTrigger: function(args){\n      this._routeArgs = this._routeArgs || [];\n      this._routeArgs.push(args);\n    },\n\n\n    /**\n     * Gets the top of the triggered route store stack\n     *\n     * @private\n     * @method _getCurrentRouteTrigger\n     * @memberOf EventRouter\n     * @returns {Array}\n     */\n    _getCurrentRouteTrigger: function(){\n      return _.last(this._routeArgs) || [];\n    },\n\n    /**\n     * Pops the latests route triggered off of the store stack\n     *\n     * @private\n     * @method _clearRouteTrigger\n     * @memberOf EventRouter\n     */\n    _clearRouteTrigger: function(){\n      this._routeArgs.pop();\n    },\n\n    /**\n     * Checks to see if the current event being tests is the latest\n     * route being handled by comparing the route name and arguments\n     *\n     * @private\n     * @method _isTriggeredFromRoute\n     * @memberOf EventRouter\n     * @returns {Boolean}\n     */\n    _isTriggeredFromRoute: function(){\n      var currentRoute = this._getCurrentRouteTrigger();\n\n      if(arguments.length !== currentRoute.length){\n        return false;\n      }\n\n      return (arguments.length === _.union(arguments, this.currentRoute).length);\n    },\n\n    /**\n     * Takes a event string and any arguments passed to that event\n     * And if not initiated by a route, translates the event into a\n     * URL and navigates to it without re-triggering the route\n     *\n     * @public\n     * @method navigateFromEvent\n     * @param {String} event - Event string\n     * @event EventRouter#noMatch - passes route arguments\n     * @memberOf EventRouter\n     * @returns {EventRouter}\n     */\n    navigateFromEvent: function(event) {\n      var route = this.getDefaultRoute(event);\n\n      // if no matching route exists do nothing\n      if(!route) {\n        this.trigger.apply(this, ['noMatch'].concat(arguments));\n        return this;\n      }\n\n      if(this._isTriggeredFromRoute.apply(this, arguments)) {\n        return this;\n      }\n\n      var eventArgs = _.drop(arguments, 0);\n\n      var translatedRoute = this.translateRoute(route, eventArgs);\n\n      // update URL without triggering the route\n      return this.navigate(translatedRoute, { trigger: false });\n    },\n\n    /**\n     * Get the default route string\n     * Either the first of the array or the passed in event if singular\n     *\n     * @public\n     * @method getDefaultRoute\n     * @memberOf EventRouter\n     * @returns {String}\n     */\n    getDefaultRoute: function(event) {\n      var routes = this._routeTriggers[event];\n\n      return _.isArray(routes) ? routes[0] : routes;\n    },\n\n    /**\n     * Finds the next name params (ie: :param) and replaces it with the arg\n     *\n     * @private\n     * @method _replaceParam\n     * @param {String} route - Route string\n     * @param {String|Number} arg - value to replace named param\n     * @memberOf EventRouter\n     * @returns {String}\n     */\n    _replaceParam: function(route, arg){\n      // https://github.com/jashkenas/backbone/blob/1.2.1/backbone.js#L1425\n      var namedParam = /(\\(\\?)?:\\w+/;\n\n      return route.replace(namedParam, arg);\n    },\n\n    /**\n     * Takes a route string and an array or arguments\n     * and returns a url with the named params replaced with the argument values\n     *\n     * @public\n     * @method translateRoute\n     * @param {String} route - Route string\n     * @param {Array} eventArgs - Passed event arguments\n     * @memberOf EventRouter\n     * @returns {String}\n     */\n    translateRoute: function(route, eventArgs) {\n      return _.reduce(eventArgs, this._replaceParam, route);\n    }\n  });\n\n  var backbone_eventrouter = EventRouter;\n\n  return backbone_eventrouter;\n\n}));\n"],"sourceRoot":"/source/"}