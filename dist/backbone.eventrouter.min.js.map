{"version":3,"sources":["/source/src/backbone.eventrouter.js"],"names":["namedParamRegex","EventRouter","Backbone","Router","extend","constructor","options","_","this","pick","cid","uniqueId","_ch","Radio","channel","result","listenTo","navigateFromEvent","apply","arguments","_initRoutes","channelName","getChannel","_routeTriggers","each","_addRouteTrigger","routes","event","isArray","route","bind","trigger","addRouteTrigger","name","callback","bbRoute","prototype","isFunction","call","history","handlers","wrappedCallback","args","drop","concat","_storeRouteTrigger","_clearRouteTrigger","_routeArgs","push","_getCurrentRouteTrigger","last","pop","_isTriggeredFromRoute","currentRoute","length","union","getDefaultRoute","eventArgs","translatedRoute","translateRoute","navigate","_replaceParam","arg","replace","reduce","destroy","reject","stopListening"],"mappings":"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","file":"backbone.eventrouter.min.js","sourcesContent":["import _ from 'underscore';\nimport Backbone from 'backbone';\nimport Radio from 'backbone.radio'; // eslint-disable-line\n\n// https://github.com/jashkenas/backbone/blob/1.2.1/backbone.js#L1425\nconst namedParamRegex = /(\\(\\?)?:\\w+/;\n\n/**\n * Backbone.Router coupled with a Backbone.Radio Channel.\n *\n * @public\n * @class EventRouter\n * @memberOf Backbone\n */\nconst EventRouter = Backbone.EventRouter = Backbone.Router.extend({\n\n  /**\n   * @public\n   * @constructs EventRouter\n   * @param {Object} [options] - Settings for the EventRouter\n   * @param {Boolean} [options.channelName]\n   * @param {Boolean} [options.routeTriggers]\n   */\n  constructor(options) {\n    _.extend(this, _.pick(options, ['channelName', 'routeTriggers']));\n\n    this.cid = _.uniqueId('bber');\n\n    this._ch = Backbone.Radio.channel(_.result(this, 'channelName'));\n\n    this.listenTo(this._ch, 'all', this.navigateFromEvent);\n\n    // Backbone.Router routes are added first\n    // Routes can be added after the triggerRoutes with the Backbone.Router API\n    Backbone.Router.apply(this, arguments);\n\n    this._initRoutes();\n  },\n\n  /**\n   * The Radio Channel name.\n   *\n   * @type {String}\n   * @default 'event-router'\n   */\n  channelName: 'event-router',\n\n  /**\n   * Get the router's Radio channel instance\n   *\n   * @public\n   * @method getChannel\n   * @memberOf EventRouter\n   * @returns {Backbone.Radio.Channel}\n   */\n  getChannel() {\n    return this._ch;\n  },\n\n  /**\n   * For each routeTrigger it adds a route to Backbone.Router\n   *\n   * @private\n   * @method _initRoutes\n   * @memberOf EventRouter\n   */\n  _initRoutes() {\n    this._routeTriggers = _.result(this, 'routeTriggers', {});\n\n    _.each(this._routeTriggers, this._addRouteTrigger, this);\n  },\n\n  /**\n   * Adds a route(s) to Backbone.Router which on route triggers\n   * the appropriate event\n   *\n   * @private\n   * @method _addRouteTrigger\n   * @param {Array|String} routes - Route string or array of route strings\n   * @param {String} event - Event string to trigger on route\n   * @memberOf EventRouter\n   */\n  _addRouteTrigger(routes, event) {\n    // handle any route as an array by default for the _.each\n    routes = _.isArray(routes) ? routes : [routes];\n\n    _.each(routes, function(route) {\n      this.route(route, event, _.bind(this._ch.trigger, this._ch, event));\n    }, this);\n  },\n\n  /**\n   * Adds a routeTrigger, and route(s) to Backbone.Router\n   * which on route triggers the appropriate event.\n   *\n   * @public\n   * @method addRouteTrigger\n   * @param {Array|String} routes - Route string or array of route strings\n   * @param {String} event - Event string to trigger on route\n   * @memberOf EventRouter\n   * @returns {EventRouter}\n   */\n  addRouteTrigger(routes, event) {\n    this._routeTriggers[event] = routes;\n    this._addRouteTrigger(routes, event);\n\n    return this;\n  },\n\n  /**\n   * Overrides `Backbone.Router.route()\n   * Like Backbone.Router.Route but with before events\n   * It also temporarily stores the event for understanding\n   * what route is currently being handled.\n   *\n   * @public\n   * @method route\n   * @param {String} route - Route string\n   * @param {String} [name] - Name of route\n   * @param {String} callback - Function called on route\n   * @event EventRouter#before:route - passes route name and route arguments\n   * @event EventRouter#before:route:{event_name} - passes route arguments\n   * @memberOf EventRouter\n   * @returns {EventRouter}\n   */\n  route(route, name, callback) {\n    const bbRoute = Backbone.Router.prototype.route;\n\n    if(_.isFunction(name) || !callback) {\n      route = bbRoute.call(this, route, name, callback);\n      Backbone.history.handlers[0].cid = this.cid;\n      return route;\n    }\n\n    const wrappedCallback = _.bind(function() {\n      const args = _.drop(arguments, 0);\n\n      // Trigger before: events that match currently triggered events\n      this.trigger('before:route', name, args);\n      this.trigger.apply(this, [`before:route:${ name }`].concat(args));\n\n      this._storeRouteTrigger([name].concat(args));\n      callback.apply(this, args);\n      this._clearRouteTrigger();\n    }, this);\n\n    route = bbRoute.call(this, route, name, wrappedCallback);\n    Backbone.history.handlers[0].cid = this.cid;\n    return route;\n  },\n\n  /**\n   * Stores the route name and route arguments on a stack\n   *\n   * @private\n   * @method _storeRouteTrigger\n   * @param {Array} args - Array of route name and route arguments\n   * @memberOf EventRouter\n   */\n  _storeRouteTrigger(args) {\n    this._routeArgs = this._routeArgs || [];\n    this._routeArgs.push(args);\n  },\n\n\n  /**\n   * Gets the top of the triggered route store stack\n   *\n   * @private\n   * @method _getCurrentRouteTrigger\n   * @memberOf EventRouter\n   * @returns {Array}\n   */\n  _getCurrentRouteTrigger() {\n    return _.last(this._routeArgs) || [];\n  },\n\n  /**\n   * Pops the latests route triggered off of the store stack\n   *\n   * @private\n   * @method _clearRouteTrigger\n   * @memberOf EventRouter\n   */\n  _clearRouteTrigger() {\n    this._routeArgs.pop();\n  },\n\n  /**\n   * Checks to see if the current event being tests is the latest\n   * route being handled by comparing the route name and arguments\n   *\n   * @private\n   * @method _isTriggeredFromRoute\n   * @memberOf EventRouter\n   * @returns {Boolean}\n   */\n  _isTriggeredFromRoute() {\n    const currentRoute = this._getCurrentRouteTrigger();\n\n    if(arguments.length !== currentRoute.length) {\n      return false;\n    }\n\n    return (arguments.length === _.union(arguments, currentRoute).length);\n  },\n\n  /**\n   * Takes a event string and any arguments passed to that event\n   * And if not initiated by a route, translates the event into a\n   * URL and navigates to it without re-triggering the route\n   *\n   * @public\n   * @method navigateFromEvent\n   * @param {String} event - Event string\n   * @event EventRouter#noMatch - passes route arguments\n   * @memberOf EventRouter\n   * @returns {EventRouter}\n   */\n  navigateFromEvent(event) {\n    const route = this.getDefaultRoute(event);\n\n    // if no matching route exists do nothing\n    if(!route) {\n      const args = _.drop(arguments, 0);\n      this.trigger.apply(this, ['noMatch'].concat(args));\n      return this;\n    }\n\n    if(this._isTriggeredFromRoute.apply(this, arguments)) {\n      return this;\n    }\n\n    const eventArgs = _.drop(arguments, 1);\n\n    const translatedRoute = this.translateRoute(route, eventArgs);\n\n    // update URL without triggering the route\n    return this.navigate(translatedRoute, { trigger: false });\n  },\n\n  /**\n   * Get the default route string\n   * Either the first of the array or the passed in event if singular\n   *\n   * @public\n   * @method getDefaultRoute\n   * @memberOf EventRouter\n   * @returns {String}\n   */\n  getDefaultRoute(event) {\n    const routes = this._routeTriggers[event];\n\n    return _.isArray(routes) ? routes[0] : routes;\n  },\n\n  /**\n   * Finds the next name params (ie: :param) and replaces it with the arg\n   *\n   * @private\n   * @method _replaceParam\n   * @param {String} route - Route string\n   * @param {String|Number} arg - value to replace named param\n   * @memberOf EventRouter\n   * @returns {String}\n   */\n  _replaceParam(route, arg) {\n    return route.replace(namedParamRegex, arg);\n  },\n\n  /**\n   * Takes a route string and an array or arguments\n   * and returns a url with the named params replaced with the argument values\n   *\n   * @public\n   * @method translateRoute\n   * @param {String} route - Route string\n   * @param {Array} eventArgs - Passed event arguments\n   * @memberOf EventRouter\n   * @returns {String}\n   */\n  translateRoute(route, eventArgs) {\n    return _.reduce(eventArgs, this._replaceParam, route);\n  },\n\n  /**\n   * Destroys the eventrouter and removes any registered route handlers.\n   *\n   * @public\n   * @method destroy\n   * @memberOf EventRouter\n   * @returns {EventRouter}\n   */\n  destroy() {\n    Backbone.history.handlers = _.reject(Backbone.history.handlers, { cid: this.cid });\n    this.stopListening();\n    this.trigger('destroy', this);\n    return this;\n  }\n});\n\nexport default EventRouter;\n\n"],"sourceRoot":"/source/"}